 spinMessageController    Uses Gemini AI to
                           rephrase/spin a
                           message (content
                           field in body)


Problems / TODOs:

 â€¢ âš ï¸ No updateTemplateController or
   deleteTemplateController â€” templates cannot be
   edited or removed
 â€¢ âš ï¸ spinMessageController â€” result.error is
   handled with instanceof Error check but then
   converts non-Error to String(result.error) â€”
   this is inconsistent with how other controllers
   handle errors
 â€¢ âš ï¸ No validation schema for createTemplate â€”
   req.body is passed raw to the service
 â€¢ âš ï¸ TemplateService.getInstance() is called
   inside each request handler (instead of once at
   module level) â€” minor inefficiency but not a
   bug

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         6. src/routes/analyticsRoutes.ts

Purpose: Defines 3 analytics endpoints, all
protected by authenticateToken.

Routes:


  Route            Handler
 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  GET /dashboard   AnalyticsController.getDashbâ€¦
  GET /usage       AnalyticsController.getUsageâ€¦
  GET /messages    AnalyticsController.getMessaâ€¦


Problems / TODOs:

 â€¢ âš ï¸ authenticateToken is applied per-route
   instead of at the router level â€” redundant but
   harmless (the parent multiTenantApp.ts already
   wraps /api/analytics with authenticateToken,
   making these middleware calls double-applied)
 â€¢ No date range filtering params are defined at
   the route level
 â€¢ No plan-level gating (e.g., advanced analytics
   might be a premium feature)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        7. src/routes/omnichannelRoutes.ts

Purpose: A comprehensive routing file for the
omnichannel gateway, covering status/health,
skills, agents, cron jobs, usage/cost analytics,
sessions, nodes/devices, and log streaming.

Route Groups:


  Group             Routes
 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  Status/Health     GET /status, GET
                    /gateway/health
  Skills            GET /skills/report
  Agents            GET /agents
  Cron Jobs         Full CRUD: list, create,
                    toggle, run, delete, get
                    runs
  Usage Analytics   Totals, daily, sessions,
                    session logs
  Sessions          List, delete, patch
  Nodes & Devices   List nodes,
                    list/approve/reject/revoke
                    devices
  Logs              GET /logs, GET /logs/stream


Problems / TODOs:

 â€¢ ğŸ” CRITICAL SECURITY GAP: GET /status, GET
   /gateway/health, and GET /skills/report use
   anonymous route handlers with NO authentication
   middleware â€” these endpoints are publicly
   accessible. The parent app mounts this router
   with authenticateToken, so they ARE protected
   at the mount level, but there is an
   inconsistency: some routes use inline handlers
   while others use OmnichannelController.* â€”
   making it unclear which are truly guarded
 â€¢ âš ï¸ uptimeMs: Date.now() in /status is wrong â€” it
   returns the current Unix timestamp in
   milliseconds, NOT uptime. Should be
   process.uptime() * 1000 or Date.now() -
   startTime
 â€¢ âš ï¸ GET /logs/stream â€” no visible rate limiting
   or connection cap for SSE/streaming endpoint
 â€¢ No authentication at the individual route level
   (relies entirely on parent mount)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       8. src/middleware/authMiddleware.ts

Purpose: JWT authentication and role-based
authorization middleware. Reads tokens from
Authorization: Bearer <token> header or token
HttpOnly cookie.

Exported Functions:


  Function            Description
 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  authenticateToken   Verifies custom JWT,
                      attaches decoded
                      UserPayload to req.user
  authorizeRole       Factory â€” returns
                      middleware that checks
                      req.user.role against an
                      allowed roles array


Global Type Augmentation: Extends Express.Request
with user?: UserPayload (fields: userId, email,
tenantId, role, iat, exp)

Patterns & Quality:

 â€¢ Dual source support (header + cookie) with
   source tracking for security logging
 â€¢ TokenExpiredError gets a specific 401 response;
   other JWT errors get 403
 â€¢ Security events are logged via
   logger.security()

Problems / TODOs:

 â€¢ âš ï¸ No token blacklisting or revocation mechanism
   â€” a stolen token is valid until expiry (7 days)
 â€¢ âš ï¸ No refresh token logic here â€” works in tandem
   with the missing refresh endpoint in
   authController.ts
 â€¢ âš ï¸ authorizeRole does not log the allowed roles
   it accepted, only what was blocked â€” harder to
   audit successful privilege escalation
 â€¢ The UserPayload interface is defined locally
   here AND redefined as AuthUserPayload in
   authController.ts â€” duplication risk if fields
   diverge

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       9. src/middleware/planMiddleware.ts

Purpose: Enforces plan-based feature gating at the
middleware level â€” checks bot limits and premium
feature access before requests reach controllers.

Exported Functions:


  Function                Description
 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  checkBotLimit           Calls
                          multiTenantService.caâ€¦
                          â€” blocks with 403 if
                          limit reached
  checkFeatureAccess(fâ€¦   Factory â€” fetches
                          tenant, calls
                          hasFeatureAccess(tenaâ€¦
                          feature), blocks with
                          403 + UPGRADE_REQUIRED
                          code if not permitted


Patterns & Quality:

 â€¢ Clean factory pattern for checkFeatureAccess
 â€¢ Uses Feature type from featureGating.ts utility
   â€” well-typed
 â€¢ Good structured error codes (LIMIT_REACHED,
   UPGRADE_REQUIRED)

Problems / TODOs:

 â€¢ âš ï¸ Uses @/ path aliases (@/services/...,
   @/utils/...) while other files use relative
   imports (../services/...) â€” inconsistency that
   could cause build issues depending on
   tsconfig.json path alias setup
 â€¢ âš ï¸ checkBotLimit throws result.error directly
   (throw result.error) â€” if result.error is
   undefined, this throws undefined, which would
   be caught by the catch block but produce a
   misleading log
 â€¢ âš ï¸ No caching â€” checkFeatureAccess does a full
   Firestore getTenant read on every single
   request that uses it; high-traffic routes could
   generate significant Firestore reads
 â€¢ No checkMessageLimit or checkCampaignLimit
   equivalents â€” only bots and features are gated

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         10. src/server/multiTenantApp.ts

Purpose: The core application server bootstrap
class. Sets up Express middleware, mounts all
route groups, initializes services (Analytics,
WebSockets, Stripe, Bots), and handles graceful
shutdown.

Exported Class: MultiTenantApp


  Method                  Role
 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  constructor             Sets up Express app,
                          HTTP server, reads
                          port from config
  initialize()            Orchestrates full
                          startup: middleware â†’
                          routes â†’ Analytics â†’
                          WebSocket â†’ services â†’
                          bots
  setupMiddleware()       Helmet, CORS,
                          compression, body
                          parsing, cookie
                          parser, rate limiting,
                          request logging
  setupRoutes()           Mounts all 15+ route
                          groups with their
                          authentication
                          wrappers
  initializeServices()    Initializes Stripe if
                          key is present
  startActiveTenantBotâ€¦   Calls
                          multiTenantBotServiceâ€¦
  start()                 Starts HTTP server,
                          registers
                          SIGTERM/SIGINT
                          handlers
  shutdown()              Gracefully stops all
                          bots, closes HTTP
                          server, exits


Route Mounting Overview:

```
/api/health          â†’ public
/api/internal        â†’ authenticateToken +
multiTenantRoutes
/api/auth            â†’ public (authRoutes)
/api/templates       â†’ templateRoutes (no auth at
mount!)
/api/analytics       â†’ authenticateToken +
analyticsRoutes
/api/contacts        â†’ authenticateToken
/api/messages        â†’ authenticateToken
/api/campaigns       â†’ authenticateToken
/api/webhooks        â†’ authenticateToken
/api/telegram        â†’ public
(telegramWebhookRoutes)
/api/omnichannel     â†’ authenticateToken +
omnichannelRoutes
/api/flows           â†’ authenticateToken
/api/skills          â†’ authenticateToken
/api/tenant          â†’ authenticateToken
/api/billing/webhook â†’ public (Stripe webhook, raw
body needed)
/api/billing         â†’ authenticateToken
```

Problems / TODOs:

 â€¢ ğŸ” /api/templates is mounted WITHOUT
   authenticateToken â€” templates endpoint is
   publicly accessible. Every other non-auth,
   non-webhook route requires auth. This is likely
   a bug
 â€¢ âš ï¸ Analytics service runs on port + 1 â€” this
   opens a second port that may not be firewalled
   or documented in deployment configs
 â€¢ âš ï¸ Double authenticateToken on analytics routes:
   applied at mount (/api/analytics) AND per-route
   in analyticsRoutes.ts
 â€¢ âš ï¸ setupRoutes registers errorHandler BEFORE
   notFoundHandler â€” the order is: error handler
   first, then 404. This is backwards:
   notFoundHandler should come before errorHandler
   so unmatched routes fall through to 404 before
   the error handler catches them. Currently,
   notFoundHandler registered after errorHandler
   will never be reached for route-not-found
   scenarios (Express error handlers are (err,
   req, res, next) â€” 4 args â€” so normal unmatched
   routes won't hit it, but it's still
   architecturally wrong and confusing)
 â€¢ âš ï¸ request logging middleware fires twice â€” once
   before and once inside setupMiddleware (two
   app.use loggers)
 â€¢ Graceful shutdown does not stop the
   AnalyticsService WebSocket server or
   socketService
 â€¢ No UNCAUGHT_EXCEPTION / UNHANDLED_REJECTION
   handlers at process level

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

         ğŸ”¥ Cross-Cutting Issues Summary


  Priority      Issue            Files Affected
 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  ğŸ”´ Critical   /api/templates   multiTenantAppâ€¦
                mounted with
                no auth
  ğŸ”´ Critical   deletePaymentâ€¦   billingControlâ€¦
                has no tenant
                ownership
                check
  ğŸŸ  High       uptimeMs:        omnichannelRouâ€¦
                Date.now() is
                incorrect â€”
                returns epoch
                not uptime
  ğŸŸ  High       Double           multiTenantAppâ€¦
                authenticateTâ€¦   +
                on analytics     analyticsRouteâ€¦
                routes
  ğŸŸ  High       @/ vs ../ path   planMiddlewareâ€¦
                alias            vs rest
                inconsistency
  ğŸŸ  High       No token         authControllerâ€¦
                refresh/revocâ€¦   +
                system           authMiddlewareâ€¦
  ğŸŸ¡ Medium     No               campaignControâ€¦
                updateCampaign
                or
                getCampaignByâ€¦
  ğŸŸ¡ Medium     No               templateControâ€¦
                updateTemplate
                or
                deleteTemplate
  ğŸŸ¡ Medium     Message          messageControlâ€¦
                listing lacks
                pagination and
                filtering
  ğŸŸ¡ Medium     Firestore        planMiddlewareâ€¦
                reads on every
                feature-gated
                request (no
                cache)
  ğŸŸ¡ Medium     UserPayload      authMiddlewareâ€¦
                defined in two   +
                places with      authControllerâ€¦
                different
                names
  ğŸŸ¡ Medium     errorHandler /   multiTenantAppâ€¦
                notFoundHandlâ€¦
                registered in
                wrong order
  ğŸŸ¡ Medium     getMe            authControllerâ€¦
                generates a
                new Firebase
                custom token
                on every call
  ğŸ”µ Low        No email         authControllerâ€¦
                verification
                enforcement on
                login
  ğŸ”µ Low        TemplateServiâ€¦   templateControâ€¦
                called
                per-request
  ğŸ”µ Low        Shutdown         multiTenantAppâ€¦
                doesn't stop
                AnalyticsServâ€¦
                or
                SocketService


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What would you like to do next? Here are the most
logical options:

 1 Fix the critical security issues â€” unprotected
   /api/templates and missing ownership check in
   deletePaymentMethod
 2 Complete missing CRUD operations â€” add
   updateCampaign, getCampaignById,
   updateTemplate, deleteTemplate
 3 Implement token refresh â€” add a
   /api/auth/refresh endpoint and revocation logic
 4 Fix the notFoundHandler/errorHandler ordering
   and the double auth middleware
 5 Add Firestore caching to planMiddleware to
   reduce read costs at scale
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”€â”€â”€ Subagent: General Purpose (Explore Config & Typâ”€
Here is the comprehensive, deep-dive analysis of
every file explored:

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

             ğŸ“ File-by-File Analysis

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
             1. src/config/config.ts

Purpose: A thin facade/bridge that assembles and
re-exports the final application configuration
object by pulling from ConfigService (a different
config provider than ConfigManager).

Exported: A default object with keys: bot, msg,
sticker, api, ai, redis, rateLimits, system,
connection.

Notable Features:

 â€¢ Formatter utility for WhatsApp markdown-style
   text (bold, italic, monospace, quote)
 â€¢ Sticker metadata hardcoded: 'WhatsDeX Sticker
   Pack' / 'CodeDeX' â€” same values appear in
   tenantConfig.ts and BotConfigSchema, creating
   triplicated defaults
 â€¢ Rate limit config pulled per-granularity:
   global, user, command, AI, download, premium

Problems / TODOs:

 â€¢ âš ï¸ validateEnvironment() function is completely
   empty â€” validation is delegated entirely to
   ConfigService, but the function body stub was
   left behind (dead code)
 â€¢ âš ï¸ Two separate config systems exist: this file
   uses configService (from ConfigService.ts),
   while redis.ts and queues.ts use configManager
   (from ConfigManager.ts) â€” this is an
   architectural inconsistency. One should be the
   single source of truth
 â€¢ âš ï¸ Sticker packname and author are hardcoded
   here instead of coming from tenant config

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          2. src/config/ConfigManager.ts

Purpose: A full-featured, singleton environment
configuration manager that loads, validates,
merges, and exports all runtime infrastructure
config from environment variables and optional
environment-specific JSON files.

Exported: Class ConfigManager, singleton instance
configManager (default export), and Config
interface.

Key Features:

 â€¢ Strongly typed Config interface covering:
   system, owner, server, database, redis, auth,
   rateLimit, bot, ai, payment, monitoring,
   features, memory
 â€¢ Deep merge of base config with
   config/{environment}.json overrides
   (loadEnvironmentConfig)
 â€¢ Typed env helpers: getEnvString, getEnvNumber,
   getEnvBoolean, getEnvArray
 â€¢ validateConfiguration(): enforces JWT_SECRET
   (non-test), REDIS_URL (production), warns on
   recommended vars
 â€¢ Auto-constructs REDIS_URL from host:port and
   exports back to process.env
 â€¢ getSafeConfig(): strips secrets (JWT, API keys,
   Stripe) for safe client-facing exposure
 â€¢ Dot-path get(path) and set(path, value) for
   dynamic nested access

Problems / TODOs:

 â€¢ âš ï¸ Parallel config system conflict:
   ConfigManager and ConfigService both exist and
   serve similar roles. redis.ts and queues.ts use
   ConfigManager, while config.ts uses
   ConfigService. This creates split configuration
   authority â€” a single service should own this
 â€¢ âš ï¸ system.timeZone is hardcoded to
   'Asia/Jakarta' â€” this should be tenant-driven
   or pulled from env
 â€¢ âš ï¸ getEnvNumber uses parseInt â€” floats like
   GOOGLE_GEMINI_TEMPERATURE: 0.7 will be
   incorrectly truncated to 0; a parseFloat should
   be used for that specific field
 â€¢ âš ï¸ database section exists in the config (with
   maxConnections, ssl, etc.) but no database
   driver (Postgres, MySQL) is configured â€” only
   Firebase/Firestore is used; this section
   appears to be dead/aspirational config
 â€¢ âš ï¸ bot.sessionPath and bot.authAdapter.authDir
   reference filesystem-based session paths, but
   ARCHITECTURE.md explicitly states: "We do NOT
   use file-based auth" â€” contradiction

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            3. src/config/constants.ts

Purpose: A minimal server-level constants file.

Exported: SERVER_CONFIG object with: PORT, ENV,
RATE_LIMIT_WINDOW_MS, RATE_LIMIT_MAX, LOG_LEVEL,
LOG_DIR.

Problems / TODOs:

 â€¢ âš ï¸ This file largely duplicates what
   ConfigManager.ts already handles (port, env,
   rate limit, log level). Nothing in the codebase
   appears to uniquely require this file â€” it's
   likely a legacy remnant or was never fully
   integrated
 â€¢ âš ï¸ RATE_LIMIT_MAX: 100 and RATE_LIMIT_WINDOW_MS:
   900000 (15 min) here differ from
   ConfigManager's defaults (maxRequests: 100,
   windowMs: 900000) â€” they happen to match but
   are maintained separately, which is fragile
 â€¢ âš ï¸ No exports from this file appear to be used
   in the rest of the codebase (unverified without
   a full grep, but the file is suspiciously small
   and isolated)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            4. src/types/contracts.ts

Purpose: The central Zod schema library and
TypeScript type source for all Firestore data
models used across the application. This is the
"single source of truth" for data contracts
between backend services and Firestore.

Exported Schemas & Types:


  Schema          Type            Description
 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  TenantSchema    Tenant          Root tenant
                                  document
  TenantUserScâ€¦   TenantUser      Users within a
                                  tenant
  BotInstanceSâ€¦   BotInstance     Bot metadata +
                                  multi-channel
                                  support
  ModerationItâ€¦   ModerationItâ€¦   Content
                                  moderation
                                  queue
  ViolationSchâ€¦   Violation       User violation
                                  records
  CommandSchema   CommandDefinâ€¦   Bot command
                                  definitions
  BotMemberSchâ€¦   BotMember       Bot
                                  interaction
                                  member data
  GroupSchema     GroupData       WhatsApp group
                                  data
  BotGroupScheâ€¦   BotGroup        Alternate/legâ€¦
                                  group schema
  Subscriptionâ€¦   Subscription    Stripe
                                  subscription
                                  data
  CampaignScheâ€¦   Campaign        Bulk messaging
                                  campaigns
  WebhookSchema   Webhook         Outbound
                                  webhooks
  LearningScheâ€¦   LearningData    Per-user AI
                                  learning/facts
  ContactSchema   Contact         Contacts for
                                  campaigns
  AudienceScheâ€¦   Audience        Segmented
                                  contact groups
  TemplateScheâ€¦   MessageTemplâ€¦   Message
                                  templates
  AuthSchema      AuthData        Baileys auth
                                  session store
  AnalyticsSchâ€¦   AnalyticsData   Daily
                                  analytics
                                  records


Also: Result<T, E> â€” a functional-style error
handling type (success/failure discriminated
union), TimestampSchema (handles both JS Date and
Firestore {_seconds, _nanoseconds} formats).

Problems / TODOs:

 â€¢ âš ï¸ GroupSchema and BotGroupSchema overlap â€” even
   labeled as -- LEGACY? in the file itself.
   BotGroupSchema should be consolidated into
   GroupSchema or clearly deprecated/removed
 â€¢ âš ï¸ BotInstanceSchema.config: z.any() is a type
   escape hatch â€” this should be typed with a
   proper schema (likely BotConfigSchema from
   tenantConfig.ts)
 â€¢ âš ï¸ AuthSchema.value: z.any() is completely
   untyped â€” Baileys auth state has a known
   structure that could be partially typed
 â€¢ âš ï¸ TenantSchema has both plan and planTier
   fields â€” they appear to be the same thing,
   creating redundancy; one is likely a migration
   artifact
 â€¢ âš ï¸ CampaignSchema.antiBan.uuid is described as
   "Strategy identifier" but is never validated or
   resolved to a known value â€” needs an enum or
   reference

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
           5. src/types/omnichannel.ts

Purpose: Defines a platform-agnostic messaging
abstraction layer â€” a normalized message format
that can represent messages from WhatsApp,
Telegram, Discord, Slack, Google Chat, and Web.

Exported Schemas & Types:


  Export                  Description
 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  PlatformSchema /        Enum of supported
  Platform                platforms
  AttachmentTypeSchema    Enum: image, video,
  / AttachmentType        audio, document,
                          location, contact,
                          sticker
  CommonAttachmentScheâ€¦   Unified attachment
  / CommonAttachment      with optional
                          location/contact
                          fields
  CommonMessageSchema /   Normalized
  CommonMessage           cross-platform message


Problems / TODOs:

 â€¢ âš ï¸ File ends at line 62 â€” this appears
   incomplete. A fully functional omnichannel
   layer would need: platform adapters, a
   PlatformAdapter interface, routing logic, and
   reply/send abstractions. The schemas are
   defined but there are no transformer functions
   (e.g., WhatsApp message â†’ CommonMessage)
 â€¢ âš ï¸ CommonMessageSchema.metadata is
   z.record(z.string(), z.any()) â€”
   platform-specific fields are dumped into an
   untyped bag; this weakens the abstraction
 â€¢ âš ï¸ ARCHITECTURE.md doesn't mention an
   omnichannel abstraction layer at all, but
   BotInstanceSchema in contracts.ts supports
   type: 'whatsapp' | 'telegram' | 'discord' |
   'slack' | 'signal' â€” this integration between
   the two files is unplanned/undocumented

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
           6. src/types/tenantConfig.ts

Purpose: Defines tenant-level and bot-level
configuration schemas stored in Firestore (not env
vars). These are customer-controlled settings
managed via the dashboard.

Exported:

 â€¢ TenantSettingsSchema / TenantSettings â€” global
   per-tenant settings
 â€¢ BotConfigSchema / BotConfig â€” per-bot behavior
   config
 â€¢ DEFAULT_TENANT_SETTINGS â€” seeding defaults for
   new tenants
 â€¢ DEFAULT_BOT_CONFIG â€” seeding defaults for new
   bots

Key Features:

 â€¢ Feature flags tied to subscription plan:
   aiEnabled, campaignsEnabled, analyticsEnabled,
   webhooksEnabled, maxBots
 â€¢ Bot behavior toggles: antiCall, autoRead,
   autoMention, autoAiLabel, autoTypingCmd,
   selfMode, alwaysOnline
 â€¢ AI config: aiEnabled, aiPersonality

Problems / TODOs:

 â€¢ âš ï¸ DEFAULT_TENANT_SETTINGS.ownerNumber is
   hardcoded to '+1234567890' â€” this is a
   placeholder that should never reach production
   but has no validation guard
 â€¢ âš ï¸ BotConfigSchema and ConfigManager's bot
   section both define prefix, mode, selfMode,
   cooldownMs, maxCommandsPerMinute â€” direct
   duplication across the env-layer config and the
   Firestore-layer config. The resolution strategy
   (which wins at runtime) is unclear
 â€¢ âš ï¸ BotConfig.status is stored in Firestore
   ('online' | 'offline' | 'connecting' | 'error')
   but BotInstanceSchema in contracts.ts uses a
   different status enum ('connected' |
   'disconnected' | 'connecting' | 'qr_pending' |
   'error') â€” inconsistent status vocabulary
   between two schemas that describe the same
   entity

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              7. src/lib/firebase.ts

Purpose: Initializes and exports the Firebase
Admin SDK (Firestore instance) using a
multi-strategy credential approach.

Exported: admin (Firebase Admin namespace), db
(Firestore instance).

Key Features:

 â€¢ Three credential strategies, in order: service
   account JSON file path â†’ inline credentials
   from env vars (FIREBASE_PROJECT_ID,
   FIREBASE_CLIENT_EMAIL, FIREBASE_PRIVATE_KEY) â†’
   Application Default Credentials (ADC)
 â€¢ Guards against double-initialization
   (admin.apps.length === 0)
 â€¢ ignoreUndefinedProperties: true on Firestore
   settings (avoids write errors for optional
   fields)
 â€¢ Properly handles the \n â†’ newline conversion
   for PEM private keys in env vars

Problems / TODOs:

 â€¢ âš ï¸ Uses ConfigService.getInstance() directly
   instead of the shared configManager â€” continues
   the two-config-system problem
 â€¢ âš ï¸ If initialization fails, it throws the error
   â€” this will crash the process at module load
   time with no graceful retry or degraded-mode
   fallback
 â€¢ âš ï¸ No Firestore emulator support wiring for
   local dev (no check for
   FIRESTORE_EMULATOR_HOST)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
               8. src/lib/redis.ts

Purpose: Creates and exports a singleton ioredis
Redis client for use across the application.

Exported: redisClient (default export, an ioredis
Redis instance).

Key Features:

 â€¢ Reads host/port/password from
   configManager.export()
 â€¢ Exponential-style retry: Math.min(times * 50,
   2000) ms delay, capped at 2 seconds
 â€¢ maxRetriesPerRequest: null set for BullMQ
   compatibility
 â€¢ Connect/error event listeners with structured
   logging

Problems / TODOs:

 â€¢ âš ï¸ Uses configManager (from ConfigManager.ts) â€”
   inconsistent with firebase.ts using
   ConfigService. This splits the config
   dependency tree
 â€¢ âš ï¸ maxRetriesPerRequest: null is correct for
   BullMQ but the comment says "though this is a
   general client" â€” if this client is also used
   for non-queue operations, null retries may
   cause hanging promises on Redis errors
 â€¢ âš ï¸ No TLS/SSL support options (no tls: {}
   config) â€” could be a problem for Redis
   deployments behind SSL (e.g., Redis Cloud,
   Upstash)
 â€¢ âš ï¸ No reconnection limit â€” on a catastrophic
   Redis failure, the client will retry
   indefinitely

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
               9. src/lib/queues.ts

Purpose: Creates and exports Bull (v3) job queues
for background task processing.

Exported: imageGenerationQueue, jobResultsQueue
(both Queue instances from the bull package).

Key Features:

 â€¢ Two active queues: image-generation and
   job-results
 â€¢ Commented-out videoProcessingQueue skeleton
   (future expansion)
 â€¢ completed and failed event listeners on both
   queues for logging
 â€¢ Redis connection shared via configManager

Problems / TODOs:

 â€¢ âš ï¸ Critical architectural mismatch:
   ARCHITECTURE.md explicitly says the stack uses
   BullMQ ("Stack: Node.js 24 | BullMQ"), but this
   file imports bull (v3, the older package).
   BullMQ and Bull are not compatible â€” they use
   different Redis data structures and APIs. This
   is a significant inconsistency
 â€¢ âš ï¸ The AIProcessor worker and CampaignWorker
   mentioned in ARCHITECTURE.md are not present â€”
   only image-generation and job-results queues
   exist, neither of which maps to the documented
   architecture
 â€¢ âš ï¸ No dead-letter queue or failed job retention
   strategy
 â€¢ âš ï¸ No queue concurrency, rate limiting, or
   backoff settings defined
 â€¢ âš ï¸ Uses configManager (same as redis.ts) but
   creates its own separate Redis connection â€”
   this means two ioredis connections exist where
   one (from redis.ts) could be reused

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          10. src/services/UsageGuard.ts

Purpose: A singleton billing enforcement guard
that checks whether a tenant/user has exceeded
their monthly message limit based on their
subscription tier.

Exported: Class UsageGuard, singleton usageGuard.

Key Features:

 â€¢ Three tiers: starter (1,000/mo), pro
   (10,000/mo), enterprise (10,000,000/mo)
 â€¢ canSend(tier, currentMonthlyUsage) â€” returns
   boolean, logs a warning when limit hit
 â€¢ getMonthlyLimit(tier) â€” returns the cap for a
   given tier
 â€¢ Singleton pattern via getInstance()

Problems / TODOs:

 â€¢ âš ï¸ Stateless by design but incomplete: the
   service accepts currentMonthlyUsage as a
   parameter rather than querying it itself. This
   means every caller must independently
   fetch/track the usage count from Firestore â€”
   there is no centralized usage
   increment/decrement logic
 â€¢ âš ï¸ No incrementUsage() method â€” how usage is
   actually tracked and persisted to Firestore is
   not implemented here
 â€¢ âš ï¸ Tier limits are hardcoded constants â€” they
   cannot be overridden per-tenant or changed
   without a code deployment
 â€¢ âš ï¸ No grace period, soft-limit warning threshold
   (e.g., warn at 90%), or overage allowance logic
 â€¢ âš ï¸ enterprise: 10_000_000 is effectively
   unlimited, but there's no explicit unlimited
   sentinel value or a bypass for enterprise,
   making the comparison always run unnecessarily

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
               11. ARCHITECTURE.md

Purpose: High-level system design document
describing the WhatsDeX backend architecture,
philosophy, and stack.

Key Content:

 â€¢ Design philosophy: Zero-Trust (Zod at all I/O
   boundaries), Service-Oriented, Event-Driven
 â€¢ Directory structure map for src/
 â€¢ WhatsApp integration via Baileys v7 with
   Firestore session persistence (no file-based
   auth)
 â€¢ Background processing via BullMQ workers:
   CampaignWorker, MediaProcessor, AIProcessor
 â€¢ Security via Node.js 24 permission model
 â€¢ Observability: OpenTelemetry tracing,
   Prometheus metrics, Pino logging

Problems / TODOs:

 â€¢ âš ï¸ Stack claim vs. reality: doc says "BullMQ"
   but queues.ts imports bull (v3) â€” directly
   contradictory
 â€¢ âš ï¸ Workers mentioned but not found:
   CampaignWorker, MediaProcessor, AIProcessor are
   described but no corresponding files appear in
   src/jobs/ (unverified but likely absent given
   the queue names in queues.ts don't match)
 â€¢ âš ï¸ "We do NOT use file-based auth" â€” but
   ConfigManager.ts configures bot.sessionPath and
   bot.authAdapter.authDir as filesystem paths
 â€¢ âš ï¸ Version is listed as 2026-01-23 â€” likely a
   typo (should be 2025)
 â€¢ âš ï¸ Omnichannel/multi-platform support is visible
   in the code (omnichannel.ts, BotInstanceSchema)
   but not documented in the architecture at all
 â€¢ âš ï¸ No mention of UsageGuard, billing
   enforcement, or Stripe integration in the
   architecture doc â€” these exist in the codebase
   but are undocumented

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

         ğŸ—ºï¸ Cross-Cutting Problems Summary


                                   Files
  #    Issue           Severity    Affected
 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  1    Dual config     ğŸ”´ High     config.ts,
       systems                     firebase.ts,
       (ConfigManagâ€¦               redis.ts,
       vs                          queues.ts
       ConfigServicâ€¦
       with no clear
       owner
  2    Bull v3 used    ğŸ”´ High     queues.ts,
       instead of                  ARCHITECTUREâ€¦
       BullMQ as
       documented
  3    Duplicate bot   ğŸŸ  Medium   ConfigManageâ€¦
       config across               tenantConfigâ€¦
       ConfigManager
       +
       BotConfigSchâ€¦
       with no merge
       strategy
  4    Inconsistent    ğŸŸ  Medium   tenantConfigâ€¦
       bot status                  contracts.ts
       enums between
       BotConfig and
       BotInstance
  5    GroupSchema +   ğŸŸ  Medium   contracts.ts
       BotGroupScheâ€¦
       overlap
       (legacy
       admitted in
       comments)
  6    omnichannel.â€¦   ğŸŸ  Medium   omnichannel.â€¦
       is incomplete
       â€” schemas
       only, no
       adapter logic
  7    UsageGuard      ğŸŸ  Medium   UsageGuard.ts
       has no
       increment
       logic â€” just
       reads, never
       writes usage
  8    Empty           ğŸŸ¡ Low      config.ts
       validateEnviâ€¦
       function stub
       left in
       config.ts
  9    constants.ts    ğŸŸ¡ Low      constants.ts
       duplicates
       what
       ConfigManager
       already
       handles
  10   getEnvNumber    ğŸŸ¡ Low      ConfigManageâ€¦
       uses parseInt
       â€” breaks
       float values
       like
       temperature
       0.7
  11   Hardcoded       ğŸŸ¡ Low      ConfigManageâ€¦
       Asia/Jakarta
       timezone in
       ConfigManager
  12   No Redis TLS    ğŸŸ¡ Low      redis.ts
       support
  13   contracts.ts    ğŸŸ¡ Low      contracts.ts
       has plan and
       planTier
       duplication
       on Tenant
  14   Undocumented    ğŸŸ¡ Low      ARCHITECTUREâ€¦
       features
       (omnichannel,
       billing,
       UsageGuard)
       in
       ARCHITECTUREâ€¦


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What would you like to tackle next? Here are a few
logical directions:

 1 Fix the dual config system â€” consolidate
   ConfigManager and ConfigService into a single
   authority and update all dependents
 2 Migrate queues.ts from Bull v3 to BullMQ â€”
   align the code with the architecture doc and
   add the missing workers
 3 Complete UsageGuard â€” add incrementUsage() with
   Firestore persistence and soft-limit warnings
 4 Resolve schema conflicts â€” merge BotGroupSchema
   into GroupSchema, unify bot status enums,
   remove plan/planTier duplication
 5 Deep-dive additional files â€” explore
   src/services/ConfigService.ts, src/jobs/, or
   other unread parts of the codebase
